{% extends "sections/template-proyectos.html" %}
{% block title %}GenIA{% endblock %}
{% block content %}
<section class="content">
	<input type="hidden" id="txt_pid" name="txt_pid" value="{{ proyecto_id }}">
	<div class="dashboard-container">
		<!-- Top Controls -->
		<div class="top-controls">
			<div class="form-group">
				<label class="form-label">Buscar x Keyword</label>
				<div id="load-keyword" class="form-input-ia">
					<input type="text" class="search-input" placeholder="Palabra clave" id="txt_keyword" name="txt_keyword">
				</div>
			</div>
			<div class="form-group">
				<label class="form-label">Fecha Inicial</label>
				<div id="load-keyword" class="form-input-ia">
					<input type="text" class="search-input" placeholder="Fecha Inicio" id="txt_fecini" name="txt_fecini" autocomplete="off">
				</div>
			</div>
			<div class="form-group">
				<label class="form-label">Fecha Final</label>
				<div id="load-keyword" class="form-input-ia">
					<input type="text" class="search-input" placeholder="Fecha Final" id="txt_fecfin" name="txt_fecfin" autocomplete="off">
				</div>
			</div>
			<div class="form-group">
				<label class="form-label">&nbsp;</label>

				<div class="filters">
					<label class="source-tag">
						<input type="checkbox" value="semrush" checked>
						<span>Semrush</span>
					</label>
					<label class="source-tag">
						<input type="checkbox" value="console">
						<span>Search Console</span>
					</label>
					<label class="source-tag">
						<input type="checkbox" value="trends">
						<span>Google Trends</span>
					</label>
				</div>
			</div>
			<div class="form-group">
				<label class="form-label">&nbsp;</label>
				<button class="add-button" id="btn_buscar">
					<span>Buscar</span>
					<span class="material-icons">search</span>
				</button>
			</div>
		</div>

		<div id="lst-tendencias"></div>
</section>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link rel="stylesheet" href="{{ url_for('static', filename='css/brandkit/tendencias.css') }}">
<script src="{{ url_for('static', filename='scripts/tendencias.js') }}"></script>
<script>
function renderStaticChart(container) {
	if (container.dataset.rendered === "true") return;
	
	const canvas = container.querySelector('.card-canvas');
	if (!canvas) return;

	const ctx = canvas.getContext('2d', { alpha: true });
	const rawData = container.getAttribute('data-chart-values');
	
	// Procesar datos para aceptar [[dia, valor], ...] o [valor, ...]
	let processedData = [];
	try {
		// Reemplazar comillas simples por dobles si es necesario para JSON.parse
		const validJson = rawData.replace(/'/g, '"');
		const parsed = JSON.parse(validJson);
		processedData = parsed.map(item => Array.isArray(item) ? { label: item[0], val: item[1] } : { label: '', val: item });
	} catch(e) {
		processedData = [{ label: '', val: 0 }];
	}
	
	// Configuración de dimensiones
	const dpr = window.devicePixelRatio || 1;
	const rect = canvas.getBoundingClientRect();
	canvas.width = rect.width * dpr;
	canvas.height = rect.height * dpr;
	ctx.scale(dpr, dpr);

	const width = rect.width;
	const height = rect.height;
	const paddingX = 10;
	const chartWidth = width - (paddingX * 2);
	const valuesOnly = processedData.map(d => d.val);
	const maxValue = Math.max(...valuesOnly, 10) * 1.1;

	const points = processedData.map((d, i) => ({
		x: paddingX + (chartWidth / (processedData.length - 1)) * i,
		y: (height - 10) - (d.val / maxValue) * (height - 20),
		value: d.val,
		label: d.label
	}));

	// 1. Dibujar Área
	const grad = ctx.createLinearGradient(0, 0, 0, height);
	grad.addColorStop(0, 'rgba(255, 165, 0, 0.75)');
	grad.addColorStop(1, 'rgba(255, 165, 0, 0.15)');
	
	ctx.beginPath();
	ctx.moveTo(points[0].x, height);
	points.forEach(p => ctx.lineTo(p.x, p.y));
	ctx.lineTo(points[points.length - 1].x, height);
	ctx.fillStyle = grad;
	ctx.fill();

	// 2. Dibujar Línea
	ctx.beginPath();
	ctx.strokeStyle = '#ffa500';
	ctx.lineWidth = 2.5;
	ctx.lineCap = 'round';
	ctx.lineJoin = 'round';
	points.forEach((p, i) => {
		if (i === 0) ctx.moveTo(p.x, p.y);
		else ctx.lineTo(p.x, p.y);
	});
	ctx.stroke();

	// 3. Dibujar Nodos
	points.forEach(p => {
		ctx.beginPath();
		ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
		ctx.fillStyle = '#ffa500';
		ctx.fill();
		ctx.beginPath();
		ctx.arc(p.x, p.y, 1.5, 0, Math.PI * 2);
		ctx.fillStyle = '#ffffff';
		ctx.fill();
	});

	container.dataset.rendered = "true";
	container.classList.add('is-visible');

	// Lógica de Tooltip
	const tooltip = container.querySelector('.card-tooltip');
	canvas.onmousemove = (e) => {
		const mouseX = e.offsetX;
		let closest = points.reduce((prev, curr) => 
			Math.abs(curr.x - mouseX) < Math.abs(prev.x - mouseX) ? curr : prev
		);

		if (Math.abs(closest.x - mouseX) < 20) {
			tooltip.style.opacity = 1;
			tooltip.style.left = closest.x + 'px';
			tooltip.style.top = closest.y + 'px';
			tooltip.innerHTML = closest.label ? `<b>${closest.label}:</b> ${closest.value}` : closest.value;
		} else {
			tooltip.style.opacity = 0;
		}
	};
	canvas.onmouseleave = () => tooltip.style.opacity = 0;
}

/**
 * INTERSECTION OBSERVER
 */
const appearanceObserver = new IntersectionObserver((entries) => {
	entries.forEach(entry => {
		if (entry.isIntersecting) {
			renderStaticChart(entry.target);
			appearanceObserver.unobserve(entry.target);
		}
	});
}, { threshold: 0.1 });

/**
 * MUTATION OBSERVER
 */
const domObserver = new MutationObserver((mutations) => {
	mutations.forEach(mutation => {
		mutation.addedNodes.forEach(node => {
			if (node.nodeType === 1) {
				const cards = node.classList.contains('card-trend') ? [node] : node.querySelectorAll('.card-trend');
				cards.forEach(card => appearanceObserver.observe(card));
			}
		});
	});
});

document.addEventListener('DOMContentLoaded', () => {
	document.querySelectorAll('.card-trend').forEach(card => appearanceObserver.observe(card));
	domObserver.observe(document.body, { childList: true, subtree: true });
});
</script>
<script>
function miGrafico(selector) {
	const canvasElements = document.querySelectorAll(selector);
	const dpr = window.devicePixelRatio || 1;

	canvasElements.forEach(canvas => {
		const ctx = canvas.getContext('2d');
		const rawData = canvas.getAttribute('data-datos');
		const color = canvas.getAttribute('data-color') || '#3b82f6';
		
		let rawParsed;
		try {
			rawParsed = JSON.parse(rawData.replace(/'/g, '"'));
		} catch (e) {
			console.error("Error al parsear datos", e);
			return;
		}

		// Normalizar datos: si es un array de arrays, extraer el segundo elemento (el valor numérico)
		const data = rawParsed.map(item => Array.isArray(item) ? item[1] : item);

		// Ajustar resolución y tamaño
		const rect = canvas.getBoundingClientRect();
		canvas.width = rect.width * dpr;
		canvas.height = rect.height * dpr;
		ctx.scale(dpr, dpr);

		const w = rect.width;
		const h = rect.height;
		const p = 4; // Padding
		const max = Math.max(...data);
		const min = Math.min(...data);
		const range = (max - min) || 1;

		ctx.clearRect(0, 0, w, h);
		
		// Dibujar línea y relleno en un solo flujo
		ctx.beginPath();
		ctx.strokeStyle = color;
		ctx.lineWidth = 2;
		ctx.lineJoin = 'round';
		ctx.lineCap = 'round';

		data.forEach((val, i) => {
			const x = (i / (data.length - 1)) * (w - p * 2) + p;
			const y = h - ((val - min) / range * (h - p * 2) + p);
			if (i === 0) ctx.moveTo(x, y);
			else ctx.lineTo(x, y);
		});
		
		// Aplicar trazo de la línea
		ctx.stroke();

		// Crear degradado y cerrar área para relleno
		ctx.lineTo((w - p), h);
		ctx.lineTo(p, h);
		ctx.closePath();
		
		const grd = ctx.createLinearGradient(0, 0, 0, h);
		grd.addColorStop(0, color + '44');
		grd.addColorStop(1, color + '00');
		ctx.fillStyle = grd;
		ctx.fill();
	});
}
</script>
{% endblock %}